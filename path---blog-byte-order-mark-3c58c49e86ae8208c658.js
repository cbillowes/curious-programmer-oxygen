webpackJsonp([0x9638839bbb44],{400:function(e,t){e.exports={data:{markdownRemark:{html:'<blockquote>\n<p>The byte order mark or BOM is an invisible Unicode magic number that can be\nfound at the beginning of a text stream.</p>\n</blockquote>\n<p>We recently changed static HTML on a web page and all Unicode characters\ndisplayed incorrectly. This was <a href="/rca/unicode-displaying-incorrectly/">caused</a>\nby the missing byte order mark in the UTF-8 file which Windows actually requires.</p>\n<p>This post was inspired by my curiosity and investigation of the byte order mark\nbut further grew as it touched on UTF, endianness and the usage of the byte order\nmark in UTF-8.</p>\n<h2 id="unicode"><a href="#unicode" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Unicode</h2>\n<p>If you are new to Unicode then I suggest you read up on it before continuing.\nYou can start by reading\n<a href="http://www.joelonsoftware.com/articles/Unicode.html">Joel Spolsky\'s</a> article\nfrom 2003.</p>\n<p>In this post I make references to Unicode code points. They are simply the\nnumerical positions of Unicode characters in the code space of 1,114,112\ncharacters.</p>\n<blockquote>\n<p>For Unicode, the particular sequence of bits is called a code unit – for\nthe UCS-4 encoding, any code point is encoded as 4-byte (octet) binary\nnumbers, while in the UTF-8 encoding, different code points are encoded as\nsequences from one to four bytes long, forming a self-synchronizing code. ~\n<a href="https://en.wikipedia.org/wiki/Code_point">Wikipedia</a></p>\n</blockquote>\n<h2 id="utf"><a href="#utf" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>UTF</h2>\n<p>UTF stands for Unicode Transformation Format. This encoding maps\nUnicode code points (from <code class="language-text">U+0000</code> to <code class="language-text">U+10FFFF</code>) to one or more code units or\n<a href="https://en.wikipedia.org/wiki/Word_(computer_architecture)">word</a> depending on\nthe encoding form (eg. UTF-8, UTF-16 and UTF-32) used.</p>\n<p>Conversions between encoding forms are algorithmic making it fast and lossless.</p>\n<p>The table below shows the different encoding forms with some of their properties.</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th align="center">UTF-8</th>\n<th align="center">UTF-16</th>\n<th align="center">UTF-32</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Code unit or word size</td>\n<td align="center">8-bit</td>\n<td align="center">16-bit</td>\n<td align="center">32-bit</td>\n</tr>\n<tr>\n<td>Fewest bytes used per character</td>\n<td align="center">1 byte</td>\n<td align="center">2 bytes</td>\n<td align="center">4 bytes</td>\n</tr>\n<tr>\n<td>Most bytes used per character</td>\n<td align="center">4 bytes</td>\n<td align="center">4 bytes</td>\n<td align="center">4 bytes</td>\n</tr>\n<tr>\n<td>Byte width for a code unit</td>\n<td align="center">Variable</td>\n<td align="center">Variable</td>\n<td align="center">Fixed</td>\n</tr>\n</tbody>\n</table>\n<p>Essentially a single character represented as a sequence of\n<code class="language-text">&lt;fewest bytes&gt;</code> to <code class="language-text">&lt;most bytes&gt;</code> <code class="language-text">&lt;code unit size&gt;</code>-bit code units or word,\ndepending on the encoding form:</p>\n<ul>\n<li>UTF-8 is variable as it can have a sequence of one to four 8-bit bytes per character</li>\n<li>UTF-16 is variable as it can have a sequence of one or two 16-bit code units per character</li>\n<li>UTF-32 is fixed as it has a single 32-bit code unit per character</li>\n</ul>\n<p>As UTF-32 is fixed length, it can get rather bloated and use up unnecessary\nmemory and storage space for strings of characters. Therefore it\'s main usage\nis in internal APIs where the data is single code points or glyphs.</p>\n<p>Let\'s look at an example using the Pilcrow sign (¶). It\'s Unicode code point\nis <code class="language-text">U+00B6</code>.</p>\n<ul>\n<li>\n<p>In UTF-8 it converts to <code class="language-text">C2 B6</code> which is a two 8-bit sequence of\n<code class="language-text">[1100 0010] [1011 0110]</code>.</p>\n</li>\n<li>\n<p>In UTF-16 it converts to <code class="language-text">00 B6</code> which is a one 16-bit sequence of\n<code class="language-text">[0000 0000 1011 0110]</code>.</p>\n</li>\n<li>\n<p>In UTF-32 it converts to <code class="language-text">00 00 00 B6</code> which is a one 32-bit sequence of\n<code class="language-text">[1011 0110 0000 0000 0000 0000 0000 0000]</code></p>\n</li>\n</ul>\n<h2 id="endianness"><a href="#endianness" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Endianness</h2>\n<p>This is just a fancy way of saying how the <strong>bytes must be ordered</strong> during the\nread and the write of the stream. This order is categorized by big-endian and\nlittle-endian.</p>\n<p>Bytes can be processed from left to right (big-endian: most significant byte\nfirst) or from right to left (little-endian: least significant byte first).</p>\n<p><img src="/endianness-4ac6d6637a110712ad1848e012fa2fa6.gif" alt="Interpretation" title="Example of a 32-bit integer committed to memory differently for big-endian and little-endian"></p>\n<p><em>Source of image: Clarice Bouwer</em></p>\n<p>As the word size for UTF-8 streams is 8-bits, one byte is read or written at a\ntime. This means the encoding form is byte-oriented so there is no byte order\nproblem for UTF-8.</p>\n<p>With UTF-16 and UTF-32 they have word sizes of 2 (16-bits) and 4 (32-bits) bytes\nrespectively making the byte order matter when it comes to certain hardware,\nprotocols or programs. The byte order is indicated with the byte order mark\nor in short, the BOM.</p>\n<p>This table shows UTF-16 and UTF-32 with their big-endian (BE)\nand little-endian (LE) equivalents. If a stream is not saved with the BOM then\nit will default to big-endian.</p>\n<table>\n<thead>\n<tr>\n<th>Encoding</th>\n<th align="center">Little-Endian</th>\n<th align="center">Big-Endian</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UTF-16</td>\n<td align="center">-</td>\n<td align="center">Default</td>\n</tr>\n<tr>\n<td>UTF-16LE</td>\n<td align="center">\\\n&#x3C;\nBOM></td>\n<td align="center">-</td>\n</tr>\n<tr>\n<td>UTF-16BE</td>\n<td align="center">-</td>\n<td align="center">\\\n&#x3C;\nBOM></td>\n</tr>\n<tr>\n<td>UTF-32</td>\n<td align="center">-</td>\n<td align="center">Default</td>\n</tr>\n<tr>\n<td>UTF-32LE</td>\n<td align="center">\\\n&#x3C;\nBOM></td>\n<td align="center">-</td>\n</tr>\n<tr>\n<td>UTF-32BE</td>\n<td align="center">-</td>\n<td align="center">\\\n&#x3C;\nBOM></td>\n</tr>\n</tbody>\n</table>\n<h2 id="byte-order-mark-bom"><a href="#byte-order-mark-bom" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Byte order mark (BOM)</h2>\n<p>It is an invisible Unicode magic number found at the beginning of a data stream\nindicating the encoding and endianness.</p>\n<p>This table shows encoding forms with their BOM byte sequence and byte order.</p>\n<table>\n<thead>\n<tr>\n<th>Encoding</th>\n<th>Endianness</th>\n<th>BOM bytes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UTF-8</td>\n<td>N/A</td>\n<td>EF BB BF</td>\n</tr>\n<tr>\n<td>UTF-16</td>\n<td>Big-endian</td>\n<td>FE FF</td>\n</tr>\n<tr>\n<td>UTF-16</td>\n<td>Little-endian</td>\n<td>FF FE</td>\n</tr>\n<tr>\n<td>UTF-32</td>\n<td>Big-endian</td>\n<td>00 00 FE FF</td>\n</tr>\n<tr>\n<td>UTF-32</td>\n<td>Little-endian</td>\n<td>FF FE 00 00</td>\n</tr>\n</tbody>\n</table>\n<p>Let\'s say we have a text stream of the following characters: <code class="language-text">¶@«®</code>. The Unicode\ncode points for each are <code class="language-text">U+00B6</code>, <code class="language-text">U+0040</code>, <code class="language-text">U+00AB</code> and <code class="language-text">U+00AE</code>.</p>\n<p><img src="/bom-eda55bc1f5ce207310b24bf6e6b13011.gif" alt="Interpretation" title="The byte order mark for UTF-16 (big-endian and little-endian) and UTF-8"></p>\n<p><em>Source of image: Clarice Bouwer</em></p>\n<p>When the UTF-16 streams are opened, the BOM defines the order the bytes must be\nread in and are read two bytes (16-bits) at a time. The way the bytes are mapped\nback to the Unicode code points are based on the endianness.</p>\n<p>When the UTF-8 stream is opened, the BOM has no impact on the byte order as\nthe bytes are read one at a time.</p>\n<p>Looking at the Heavy Black Heart (❤) character at code point <code class="language-text">U+2764</code>:</p>\n<ul>\n<li>\n<p>In UTF-8 it converts to <code class="language-text">E2 9D A4</code> which is a three 8-bit sequence of\n<code class="language-text">[1110 0010] [1001 1101] [1010 0100]</code>.</p>\n</li>\n<li>\n<p>In UTF-16BE it converts to <code class="language-text">27 64</code> which is a one 16-bit sequence of\n<code class="language-text">[0010 0111 0110 0100]</code>.</p>\n</li>\n<li>\n<p>In UTF-16LE it converts to <code class="language-text">64 27</code> which is a one 16-bit sequence of\n<code class="language-text">[0110 0100 0010 0111]</code>.</p>\n</li>\n<li>\n<p>In UTF-32BE it converts to <code class="language-text">00 00 27 64</code> which is a one 32-bit sequence of\n<code class="language-text">[0000 0000 0000 0000 0010 0111 0110 0100]</code>.</p>\n</li>\n<li>\n<p>In UTF-32LE it converts to <code class="language-text">64 27 00 00</code> which is a one 32-bit sequence of\n<code class="language-text">[0110 0100 0010 0111 0000 0000 0000 0000]</code>.</p>\n</li>\n</ul>\n<h2 id="utf-8"><a href="#utf-8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>UTF-8</h2>\n<p>When the BOM exists it acts as an <strong>encoding signature</strong> only. In this case it\nis referred to as the UTF-8 signature.</p>\n<p>Although it is optional and doesn\'t signify the byte order, some applications\nrequire its presence. I learned the <a href="/rca/unicode-displaying-incorrectly">hard way</a>\nwith Microsoft Windows and some of its applications.</p>\n<blockquote>\n<p>Microsoft compilers and interpreters, and many pieces of software on\nMicrosoft Windows such as Notepad treat the BOM as a required magic\nnumber rather than use heuristics. These tools add a BOM when saving text\nas UTF-8, and cannot interpret UTF-8 unless the BOM is present, or the file\ncontains only ASCII bytes. ~ <a href="https://en.wikipedia.org/wiki/Byte_order_mark">Wikipedia</a></p>\n</blockquote>\n<p>There are also instances where the BOM must not exist. This can include files\nthat need to start with specific characters like the human readable shebang\nmagic number (<code class="language-text">#!</code>) in Unix shell scripts.</p>\n<p>It\'s also nice to know that ASCII is a subset of Unicode. It is a 7-bit encoding\nbut 1 bit goes unused and is always saved as 1 byte. This makes UTF-8 backwards\ncompatible with ASCII assuming the file doesn\'t use characters outside of the\nASCII range.</p>\n<p>If the BOM exists but cannot be interpreted correctly the file will start with\n<code class="language-text">ï»¿</code>. An example is viewing the BOM file with the Latin 1 (ISO 8859-1)\ncharacter encoding.</p>\n<h2 id="bom-guidelines"><a href="#bom-guidelines" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>BOM guidelines</h2>\n<p>If you are working directly with a stream or are uncertain of which encoding to\nuse, <a href="http://unicode.org/faq/utf_bom.html">Unicode.org</a> has the following\nguidelines for dealing with the BOM:</p>\n<ul>\n<li>\n<p>A particular protocol (e.g. Microsoft conventions for .txt files) may require\nuse of the BOM on certain Unicode data streams, such as files. When you\nneed to conform to such a protocol, use a BOM.</p>\n</li>\n<li>\n<p>Some protocols allow optional BOMs in the case of untagged text. In those cases,</p>\n<ul>\n<li>Where a text data stream is known to be plain text, but of unknown encoding,\nBOM can be used as a signature. If there is no BOM, the encoding could be\nanything.</li>\n<li>Where a text data stream is known to be plain Unicode text\n(but not which endian), then BOM can be used as a signature. If there is no\nBOM, the text should be interpreted as big-endian.</li>\n</ul>\n</li>\n<li>\n<p>Some byte oriented protocols expect ASCII characters at the beginning of a\nfile. If UTF-8 is used with these protocols, use of the BOM as encoding form\nsignature should be avoided.</p>\n</li>\n<li>\n<p>Where the precise type of the data stream is known (e.g. Unicode big-endian\nor Unicode little-endian), the BOM should not be used. In particular,\nwhenever a data stream is declared to be UTF-16BE, UTF-16LE, UTF-32BE or\nUTF-32LE a BOM must not be used.</p>\n</li>\n</ul>\n<p><small>This excerpt can be found under the question "<strong>How I should deal with\nBOMs?</strong>"</small></p>\n<h2 id="my-final-thoughts"><a href="#my-final-thoughts" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>My final thoughts</h2>\n<p>The BOM is usually handled in the background by the systems you are working\non. As it is invisible it generally goes unnoticed.</p>\n<p>If you start to experience some funny visuals, you are most likely experiencing\nan encoding problem that can easily be fixed. Using a Hex Editor you can\nidentify the invisible bytes in a file.</p>\n<hr>\n<h2 id="references"><a href="#references" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>References</h2>\n<ul>\n<li><a href="/rca/unicode-displaying-incorrectly/">Root cause analysis</a> inspiring this post</li>\n<li><a href="http://unicode.org/standard/WhatIsUnicode.html">What is Unicode?</a> - Unicode.org</li>\n<li><a href="http://www.joelonsoftware.com/articles/Unicode.html">Introduction to Unicode</a> - Joel on Software</li>\n<li><a href="https://en.wikipedia.org/wiki/Code_point">Unicode code point</a> - Wikipedia.org</li>\n<li><a href="http://unicode-table.com/">Unicode character table</a> - Unicode-table.com</li>\n<li><a href="https://en.wikipedia.org/wiki/Endianness">Endianness</a> - Wikipedia.org</li>\n<li><a href="https://en.wikipedia.org/wiki/Byte_order_mark">Byte order mark</a> - Wikipedia.org</li>\n<li><a href="http://unicode.org/faq/utf_bom.html">FAQs</a> (UTF-8, UTF-16, UTF-32 &#x26; BOM) - Unicode.org</li>\n<li><a href="https://www.w3.org/International/questions/qa-byte-order-mark">The byte order mark in HTML</a> - W3.org</li>\n<li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd374101(v=vs.85).aspx">Using byte order marks</a> - MSDN</li>\n<li><a href="http://www.utf-8.com/">UTF-8</a> - Utf-8.com</li>\n<li><a href="http://www.moserware.com/2008/02/does-your-code-pass-turkey-test.html">The Turkey Test</a> - moserware.com</li>\n</ul>\n<p><a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>\n© 2016 W3C® (<a href="http://www.csail.mit.edu/">MIT</a>, <a href="http://www.ercim.eu/">ERCIM</a>,\n<a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>).\nThis document includes material copied from or derived from\n<a href="https://www.w3.org/International/questions/qa-byte-order-mark">The byte-order mark (BOM) in HTML</a>."\nThe <a href="/img/posts/byte-order-mark/bom.gif">BOM</a>\nimage in this post adapted from their endianness image.</p>',timeToRead:9,excerpt:"The byte order mark or BOM is an invisible Unicode magic number that can be\nfound at the beginning of a text stream. We recently changed…",frontmatter:{title:"Byte order mark",cover:"https://picsum.photos/1280/500/?image=8",date:"2016-10-09 14:28:00 +0200",category:null,tags:["Technical"]},fields:{slug:"/blog/byte-order-mark"}},prev:{excerpt:"“Did I do anything wrong today,” he said, “or has the world always been like\nthis and I've been too wrapped up…",frontmatter:{title:"The imposter within",cover:"https://picsum.photos/1280/500/?image=680",date:"2016-11-13 11:23:10 +0200"},fields:{slug:"/blog/the-imposter-within"}},next:{excerpt:"When someone new works on your repository, make sure it is easy to get setup. Imagine if we didn't have any…",frontmatter:{title:"Contributing to the README",cover:"https://picsum.photos/1280/500/?image=528",date:"2016-09-24 15:00:49 +0200"},fields:{slug:"/blog/contributing-to-the-readme"}}},pathContext:{slug:"/blog/byte-order-mark",total:57,prev:"/blog/the-imposter-within",next:"/blog/contributing-to-the-readme"}}}});
//# sourceMappingURL=path---blog-byte-order-mark-3c58c49e86ae8208c658.js.map